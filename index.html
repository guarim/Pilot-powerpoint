<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Gesture Diaporama Debug + Drawing Tools</title>
  <style>
    body { display:flex; flex-direction:row; gap:20px; font-family:sans-serif; }
    #left { display:flex; flex-direction:column; gap:10px; }
    #viewer { width:800px; height:450px; border:1px solid #ccc; background-size:contain; background-repeat:no-repeat; background-position:center; }
    #drawCanvas, #videoCanvas { position:absolute; left:0; top:0; }
    #wrapper { position:relative; width:800px; height:450px; }
    #debug { width:350px; height:450px; overflow:auto; border:1px solid #999; padding:10px; background:#f7f7f7; }
    #fingerState { display:flex; gap:4px; margin-top:10px; }
    .fingerBox { width:40px; height:40px; border-radius:6px; border:1px solid #777; display:flex; justify-content:center; align-items:center; font-size:12px; }
    #tools { margin-top:15px; padding:10px; border:1px solid #aaa; background:#eee; }
  </style>
</head>
<body>
  <div id="left">
    <h2>Diaporama + Dessin</h2>
    <div id="wrapper">
      <div id="viewer"></div>
      <canvas id="drawCanvas" width="800" height="450"></canvas>
      <canvas id="videoCanvas" width="800" height="450"></canvas>
    </div>

    <div id="tools">
      <label>Couleur: <input type="color" id="colorPicker" value="#ff0000"></label>
      <label style="margin-left:10px;">Épaisseur: <input type="range" id="widthPicker" min="1" max="20" value="4"></label>
      <button id="saveBtn">Enregistrer le dessin</button>
    </div>
  </div>

  <div id="debug">
    <h3>Debug</h3>
    <pre id="debugText">En attente...</pre>

    <h4>État des doigts (main droite)</h4>
    <div id="fingerState">
      <div class="fingerBox" id="thumbBox">Pouce</div>
      <div class="fingerBox" id="indexBox">Index</div>
      <div class="fingerBox" id="middleBox">Majeur</div>
      <div class="fingerBox" id="ringBox">Annulaire</div>
      <div class="fingerBox" id="pinkyBox">Auriculaire</div>
    </div>
  </div>

  <video id="video" autoplay playsinline style="display:none"></video>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    async function loadImages() {
      let list = [];
      for (let i=1;i<500;i++) {
        try {
          const res = await fetch(`asset/${i}.png`,{method:"HEAD"});
          if (res.ok) list.push(`asset/${i}.png`);
        } catch {}
      }
      return list;
    }

    let images = [];
    let index = 0;
    const viewer = document.getElementById("viewer");

    loadImages().then(imgs => {
      images = imgs;
      viewer.style.backgroundImage = `url(${images[0]})`;
    });

    const drawCanvas = document.getElementById("drawCanvas");
    const drawCtx = drawCanvas.getContext("2d");
    const videoCanvas = document.getElementById("videoCanvas");
    const videoCtx = videoCanvas.getContext("2d");
    const debugText = document.getElementById("debugText");

    let color = document.getElementById("colorPicker").value;
    let width = document.getElementById("widthPicker").value;
    document.getElementById("colorPicker").oninput = e => color = e.target.value;
    document.getElementById("widthPicker").oninput = e => width = e.target.value;

    document.getElementById("saveBtn").onclick = () => {
      const link = document.createElement("a");
      link.download = "dessin.png";
      link.href = drawCanvas.toDataURL();
      link.click();
    };

    function nextImage() {
      if (images.length === 0) return;
      index = (index + 1) % images.length;
      viewer.style.backgroundImage = `url(${images[index]})`;
    }

    function prevImage() {
      if (images.length === 0) return;
      index = (index - 1 + images.length) % images.length;
      viewer.style.backgroundImage = `url(${images[index]})`;
    }

    function clearDrawing() {
      drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
    }

    function isFingerUp(lm, tip, pip) {
      return lm[tip].y < lm[pip].y;
    }

    function getFingerStates(lm) {
      return {
        thumb: lm[4].x < lm[3].x,
        index: isFingerUp(lm,8,6),
        middle: isFingerUp(lm,12,10),
        ring: isFingerUp(lm,16,14),
        pinky: isFingerUp(lm,20,18)
      };
    }

    function updateFingerBoxes(state) {
      const map = {
        thumbBox: state.thumb,
        indexBox: state.index,
        middleBox: state.middle,
        ringBox: state.ring,
        pinkyBox: state.pinky
      };
      for (let id in map) {
        document.getElementById(id).style.background = map[id] ? "#7f7" : "#f77";
      }
    }

    function isFist(lm) {
      const s = getFingerStates(lm);
      return !s.thumb && !s.index && !s.middle && !s.ring && !s.pinky;
    }

    function isIndexOnly(lm) {
      const s = getFingerStates(lm);
      return s.index && !s.middle && !s.ring && !s.pinky;
    }

    function isPinch(lm) {
      const dx = lm[8].x - lm[4].x;
      const dy = lm[8].y - lm[4].y;
      return Math.hypot(dx,dy) < 0.02;
    }

    let lastRightX = null;
    let gestureCooldown = 0;
    let lastX = null, lastY = null;

    function drawHands(image, hands) {
      videoCtx.clearRect(0,0,videoCanvas.width,videoCanvas.height);
      videoCtx.drawImage(image,0,0,videoCanvas.width,videoCanvas.height);
      for (const lm of hands) {
        window.drawConnectors(videoCtx, lm, window.HAND_CONNECTIONS);
        window.drawLandmarks(videoCtx, lm);
      }
    }

    function onResults(results) {
      if (gestureCooldown > 0) gestureCooldown--;

      drawHands(results.image, results.multiHandLandmarks || []);

      debugText.textContent = JSON.stringify(results.multiHandedness, null, 2);

      if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

      let right = null, left = null;
      results.multiHandedness.forEach((h,i)=>{
        if (h.label === "Right") right = results.multiHandLandmarks[i];
        else left = results.multiHandLandmarks[i];
      });

      if (right) updateFingerBoxes(getFingerStates(right));

      if (right) {
        const rx = right[9].x;
        if (lastRightX !== null && gestureCooldown === 0) {
          if (left && isFist(left)) {
            if (rx - lastRightX > 0.10) { nextImage(); gestureCooldown = 25; }
            if (lastRightX - rx > 0.10) { prevImage(); gestureCooldown = 25; }
          }
        }
        lastRightX = rx;
      }

      if (right && left && isFist(left) && isIndexOnly(right)) {
        const x = right[8].x * drawCanvas.width;
        const y = right[8].y * drawCanvas.height;
        if (lastX === null) { lastX = x; lastY = y; }
        drawCtx.beginPath();
        drawCtx.moveTo(lastX,lastY);
        drawCtx.lineTo(x,y);
        drawCtx.strokeStyle = color;
        drawCtx.lineWidth = width;
        drawCtx.stroke();
        lastX = x; lastY = y;
      } else { lastX=null; lastY=null; }

      if (right && isPinch(right)) clearDrawing();

      if (right && left && isFist(right) && isFist(left)) {
        alert("Programme arrêté");
        location.reload();
      }
    }

    const video = document.getElementById("video");
    const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
    hands.onResults(onResults);

    const camera = new Camera(video, {
      onFrame: async () => { await hands.send({image: video}); },
      width: 640,
      height: 480
    });
    camera.start();
  </script>
</body>
</html>
